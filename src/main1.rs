// ============================================================================
// スタック
// ============================================================================
// Vec を使用する
fn sample_stack() {
    let mut stack = Vec::new();
    stack.push(2);
    stack.push(3);
    assert_eq!(stack.pop(), Some(3));
    assert_eq!(stack.pop(), Some(2));
    assert_eq!(stack.pop(), None);
}

// ============================================================================
// キュー
// ============================================================================
// VeDeque がリングバッファによる両端キューとなっている.
// これの末尾および先頭への追加・削除が高速.
use std::collections::VecDeque;
fn sample_queue() {
    let mut q = VecDeque::new();
    q.push_front(2);
    q.push_front(3);
    q.push_front(5);
    assert_eq!(q.pop_back(), Some(2));
    assert_eq!(q.pop_back(), Some(3));
    assert_eq!(q.pop_back(), Some(5));
    assert_eq!(q.pop_back(), None);
}

// ============================================================================
// 深さ優先探索
// ============================================================================
// 深さ優先探索（Depth-First Search, DFS）は、ある状態から始めて、
// 遷移できなくなるまで状態を進め、遷移できない場合は1つ前に戻る、というもの.

// ============================================================================
// 幅優先探索
// ============================================================================
// 幅優先探索（Breadth-First Search, BFS）は、（暗に）キューを使用する.
// DFS では暗にスタックを使用していた。



// ---------------------------------------------------------------------------
// (Q)
// 部分和問題
// 整数a1, a2, .. ak が与えられる. その中からいくつかを選び、その和を
// ちょうど k にすることができるかどうかを判定する.

// (A)
fn dfs_partial_sum(depth: usize, sum: u16, a: &Vec<u16>, goal: u16) -> bool {
    if depth == a.len() { return sum == goal }
    if dfs_partial_sum(depth + 1, sum + a[depth], &a, goal) { return true }
    if dfs_partial_sum(depth + 1, sum, &a, goal) { return true }
    return false
}

// (A_test)
fn dfs_partial_sum_test() {
    assert_eq!(true, dfs_partial_sum(0, 0, &vec!(1,2,3,4,5), 10));
    assert_eq!(false, dfs_partial_sum(0, 0, &vec!(1,2,3), 10));
    assert_eq!(true, dfs_partial_sum(0, 0, &vec!(1,2,3), 1));
    assert_eq!(true, dfs_partial_sum(0, 0, &vec!(1,2,3), 0));
    assert_eq!(false, dfs_partial_sum(0, 0, &vec!(1,2,3), 7));
}


// ---------------------------------------------------------------------------
// (Q)
// 水溜りのカウント
// 大きさがNxMの庭があり、そこに雨が降って水溜りができた。
// 水溜りは 8 近傍で隣接している場合につながっているとみなす。
// 全部でいくつの水溜りがあるのか、数え上げろ。

// NG. 解き直し
// ポイント
// ・NxM の庭は char の NxM 行列として表す.
// ・「適当な W から始め、そこから繋がっているものを . に置き換えていく」これを
//    何回繰り返したかで W を数える.
// ・8 方向をチェックするのは for x in -1..1 , for y in -1..1 で表す.

fn dfs_lake_counting(r: ( usize, usize ), count: u16, world: Vec<&str>) {
}

fn dfs_lake_counting_test() {
    dfs_lake_counting((0,0), 0, vec!(
      "W........WW.",
      ".WWW.....WWW",
      "....WW...WW.",
      ".........WW.",
      ".........W..",
      "..W......W..",
      ".W.W.....WW.",
      "W.W.W.....W.",
      ".W.W......W.",
      "..W.......W.",
    ));
}


// ---------------------------------------------------------------------------
// (Q) 迷路の最短経路
// 大きさが NxM の迷路が与えられる. 迷路は通路と壁からできており、1ターンに隣接
// する上下左右 4 マスの通路へ移動できる。スタートからゴールまで移動するのに
// 必要な最小のターン数を求めよ.

// NG. 解き直し
// ポイント
// ・8方向への移動を効率よく記述するために下の配列を定義しておくと良い
//   ・dx = [-1, 0, 1]
//   ・dy = [-1, 0, 1]
// ・queue には次の可能性がある点 (x,y) のみを入れる.
// ・迷路を NxM 行列として表す.
// ・スタートからの距離を NxM 行列として表す.

// (A)
fn solve_maze(world: Vec<&str>) -> u16 {
    0
}

// (A_test)
fn solve_maze_test() {
    solve_maze(vec!(
      "#S######.#",
      "......#..#",
      ".#.##.##.#",
      ".#........",
      "##.##.####",
      "....#....#",
      ".#######.#",
      "....#.....",
      ".####.###.",
      "....#...G#",
    ));
}


fn main() {
    sample_stack();
    sample_queue();
    dfs_partial_sum_test();
    solve_maze_test();
}
